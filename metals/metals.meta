.SYNTAX METALS

METALS =
.DIRECT("section .data")
.DIRECT("fn_arg_count dd 0")
.DIRECT("fn_arg_num dd 0")
// Keep track of whether we are in the root body of a function
.DIRECT("in_body db 0")
// Check whether we already returned at a root level, then we don't have to output the default return
.DIRECT("returns_from_body db 0")
.DIRECT("section .bss")
.DIRECT("symbol_table resb 262144")
.DIRECT("section .text")
.LABEL("section .text")
->("global _start")
.LABEL("_start:")
$(FUNCTION_DECLARATION | WHILE | STATEMENT)
.LABEL("exit:")
->("push ebp")
->("mov ebp, esp")
// Exit the program
->("mov eax, 1")
// Get the exit code from the first passed argument
->("mov ebx, dword [ebp+8]")
->("int 0x80");

// -------------------------------- Functions ----------------------------------

FUNCTION_DECLARATION = "fn"
	// Skip the function so we don't accidentally enter it.
	->("jmp " *1) ID
	.LABEL(* ":")
	->("push ebp")
	->("mov ebp, esp")
	"(" (FUNCTION_PARAM $("," FUNCTION_PARAM) | .EMPTY) ")"
	.DIRECT("add dword [fn_arg_num], 2") "{"
	FUNCTION_BODY
	.DIRECT("mov dword [fn_arg_num], 0")
	.DIRECT("mov dword [fn_arg_count], 0")
	->("mov esp, ebp")
	->("pop ebp")
	->("ret")
	.LABEL(*1 ":")
"}";

FUNCTION_PARAM = TYPE NAME
	.DIRECT("inc dword [fn_arg_count] ; found new argument!")
	.DIRECT("inc dword [fn_arg_num]")
	.DIRECT("mov edx, dword [fn_arg_num]")
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, last_match")
	.DIRECT("call hash_set");

FUNCTION_BODY = $(WHILE | STATEMENT);

STATEMENT = ("%var" TYPE NAME 
		// write the index into the symbol table
		.DIRECT("inc dword [fn_arg_num]")
		.DIRECT("mov edx, dword [fn_arg_num]")
		.DIRECT("mov edi, symbol_table")
		.DIRECT("mov esi, last_match")
		.DIRECT("call hash_set")
		"," VALUE<"eax"> MOV_INTO ->("eax"))
	| ("%push" VALUE<"eax">
			->("push eax"))
	| ("%add" ARITHMETIC_OPERATION_ARGS
			->("add eax, ebx"))
	| ("%neq" ARITHMETIC_OPERATION_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("setne al"))
	| ("%eq" ARITHMETIC_OPERATION_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("sete al"))
	| ("%lt" ARITHMETIC_OPERATION_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("setlt al"))
	| ("%gt" ARITHMETIC_OPERATION_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("setgt al"))
	| ("%deref/byte" VALUE<"eax">
			->("mov eax, byte [eax]"))
	| ("%deref/word" VALUE<"eax">
			->("mov eax, word [eax]"))
	| ("%deref/dword" VALUE<"eax">
			->("mov eax, dword [eax]"))
	| ("%set" NAME % "," VALUE<"eax">
		SET_INTO ->("eax"))
	| ("%ret" (VALUE<"eax"> | .EMPTY)
		->("mov esp, ebp")
		->("pop ebp")
		->("ret"))
	| (ID % FUNCTION_CALL_ARGS
		->("call " %));

// ----------------------------- Function Calls --------------------------------

FUNCTION_CALL_ARGS = (FUNCTION_CALL_ARG<"esi"> 
	$("," FUNCTION_CALL_ARG<"edi"> 
		$("," FUNCTION_CALL_ARG<"edx"> 
			$("," FUNCTION_CALL_ARG<"ecx"> 
				$("," FUNCTION_CALL_ARG_REST)))) | .EMPTY);

FUNCTION_CALL_ARG<reg> = NUMBER
		->("mov " *reg ", " *)
	| STRING
		.LABEL("section .data")
			->(*3 " db " * ", 0x00")
		.LABEL("section .text")
			->("mov " *reg ", " *3)
	| SYMBOL_TABLE_ID<"eax">
		->("mov " *reg ", eax")
	| RESULT_SPECIFIER
		->("mov " *reg ", eax");

FUNCTION_CALL_ARG_REST = NUMBER
		->("push " *)
	| STRING
		.LABEL("section .data")
			->(*3 " db " * ", 0x00")
		.LABEL("section .text")
			->("push " *3)
	| SYMBOL_TABLE_ID<"eax">
		->("push, eax")
	| RESULT_SPECIFIER
		->("push, eax");

// --------------------- Arithmetic Operation Arguments ------------------------

ARITHMETIC_OPERATION_ARGS = (NUMBER % "," (
		NUMBER
			->("mov ebx, " *)
		// TODO: Change to generics SYMBOL_TABLE_ID<"ebx">	
		| SYMBOL_TABLE_ID<"ebx">
		| RESULT_SPECIFIER
			->("mov ebx, eax"))
			->("mov eax, " %))
	| (RESULT_SPECIFIER "," (
			NUMBER
			->("mov ebx, " *)
		| SYMBOL_TABLE_ID<"ebx">
		| RESULT_SPECIFIER
			->("mov ebx, eax")))
	| (SYMBOL_TABLE_ID<"eax"> "," (
			NUMBER
			->("mov ebx, " *)
		| SYMBOL_TABLE_ID<"ebx">
		| RESULT_SPECIFIER
			->("mov ebx, eax")));

SET_INTO = 
	.RS("mov dword [ebp")
	// set the value of the variable
	// we can use the symbol table to get the index of the variable
	// then calculate the offset by doing `8 + (arg_count - index) * 4`
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, str_vector_8192")
	.DIRECT("call vector_pop_string")
	.DIRECT("mov esi, eax")
	.DIRECT("call hash_get") // index is now in eax
	.DIRECT("mov ebx, dword [fn_arg_count]")
	.DIRECT("sub ebx, eax") // (arg_count - index)
	.DIRECT("imul eax, ebx, 4") // (arg_count - index) * 4
	.DIRECT("add eax, 8") // 8 + (arg_count - index) * 4
	.DIRECT("mov esi, eax")
	.DIRECT("mov edi, outbuff")
	.DIRECT("add edi, dword [outbuff_offset]")
	.DIRECT("call inttostrsigned")
	.DIRECT("add dword [outbuff_offset], eax")
	.RS("], ");

MOV_INTO = .RS("mov dword [ebp")
	// use the symbol table to get the index of the variable
	// then calculate the offset by doing `8 + (arg_count - index) * 4`
	.DIRECT("mov eax, dword [fn_arg_num]") // index is now in eax
	.DIRECT("mov ebx, dword [fn_arg_count]")
	.DIRECT("sub ebx, eax") // (arg_count - index)
	.DIRECT("imul eax, ebx, 4") // (arg_count - index) * 4
	.DIRECT("add eax, 8") // 8 + (arg_count - index) * 4
	.DIRECT("mov esi, eax")
	.DIRECT("mov edi, outbuff")
	.DIRECT("add edi, dword [outbuff_offset]")
	.DIRECT("call inttostrsigned")
	.DIRECT("add dword [outbuff_offset], eax")
	.RS("], ");

// --------------------------------- Types ------------------------------------

TYPE = "i32";

// TODO: Replace with generics
VALUE<reg> = NUMBER
		->("mov eax, " *)
	| STRING
		.LABEL("section .data")
			->(*3 " db " * ", 0x00")
		.LABEL("section .text")
			->("mov eax, " *3)
	| SYMBOL_TABLE_ID<reg>
	| RESULT_SPECIFIER;

RESULT_SPECIFIER = "$";

SYMBOL_TABLE_ID<reg> = NAME
	// We need to get the index of the argument from the symbol table
	// We can do this by doing `8 + (arg_count - index) * 4`
	// This will account for the 8 bytes of the function call (esp and ip)
	.RS("mov " *reg ", dword [ebp")
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, last_match")
	.DIRECT("call hash_get") // Index is now in eax
	.DIRECT("mov ebx, dword [fn_arg_count]")
	.DIRECT("sub ebx, eax") // (arg_count - index)
	.DIRECT("imul eax, ebx, 4") // (arg_count - index) * 4
	.DIRECT("add eax, 8") // 8 + (arg_count - index) * 4
	.DIRECT("mov esi, eax") // print the number
	.DIRECT("mov edi, outbuff")
	.DIRECT("add edi, dword [outbuff_offset]")
	.DIRECT("call inttostrsigned")
	.DIRECT("add dword [outbuff_offset], eax")
	->("] ; get " *);

// ---------------------------------- While ------------------------------------

WHILE = "while" "(" .LABEL(*1 ":") $(STATEMENT) 
	->("cmp al, 1")
	// Jump to the end of the while loop if the condition is false
	->("jne " *2) ")" "{"
	$(STATEMENT)
	->("jmp " *1)
	.LABEL(*2 ":")
"}";

// -------------------------------- Comments -----------------------------------

COMMENT = "//" .NOT 10;

.TOKENS

// Remove any leading whitespace
PREFIX = $.ANY(32!9!13!10);

// Match numbers (sequence of digits)
NUMBER = PREFIX .TOKEN DIGIT $DIGIT .DELTOK;

// Match any digit
DIGIT  = .ANY(48:57);

// Match any sequence of characters and digits, may not start with a digit.
ID     = PREFIX .RESERVED("while") .TOKEN ALPHA $(ALPHA | DIGIT) .DELTOK;

NAME = PREFIX .ANY(64) .TOKEN ALPHA $(ALPHA | DIGIT) .DELTOK;

// Matches any uppercase or lowercase character as well as underscore
ALPHA  = .ANY(65:90!95!97:122) ;

// Matches anything but double quotes that is enclosed by double quotes.
// e.g. "hello world" but not "awd "inner" "
STRING = PREFIX .TOKEN .ANY(34) $.ANYBUT(13!10!34) .ANY(34) .DELTOK;

// Same as STRING but does not capture the double quotes.
RAW 	 = PREFIX .ANY(34) .TOKEN $.ANYBUT(13!10!34) .DELTOK .ANY(34);