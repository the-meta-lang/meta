.SYNTAX LISP

LISP =
.DIRECT("section .data")
.DIRECT("fn_arg_count dd 0")
.DIRECT("fn_arg_num dd 0")
.DIRECT("call_arg_count dd 0")
.DIRECT("indent dd 0")
.DIRECT("section .bss")
.DIRECT("call_arg_count_vector resb 512")
.DIRECT("symbol_table resb 262144")
.DIRECT("section .text")
$(ROOT_BODY);

ROOT_BODY = COMMENT | "[" (DEFUNC | DEFINE | SET | WHILE | IF_ELSE | IF | ASM | MOV | FUNC_CALL) "]";

// ---------------------------------- body -------------------------------------

BODY = COMMENT | "[" (DEFINE | SET | WHILE | IF_ELSE | IF | ARITHMETIC | ASM | MOV | RETURN | FUNC_CALL) "]";

// --------------------------------- arithmetic --------------------------------

ARITHMETIC = ("+" ARITHMETIC_ARGS<"%add">
	| "-" ARITHMETIC_ARGS<"%sub">
	| "*" ARITHMETIC_ARGS<"%imul">
	| "/" ARITHMETIC_ARGS<"%idiv">
	| "%" ARITHMETIC_ARGS<"%mod">
	| "==" ARITHMETIC_ARGS<"%eq">
	| "!=" ARITHMETIC_ARGS<"%neq">
	| "<" ARITHMETIC_ARGS<"%lt">
	| ">" ARITHMETIC_ARGS<"%gt">);

// ----------------------------- Arithmetic Args -------------------------------

// Implement all different types of arithmetic argument combinations
// like:
//	 number, number
//	 number, id
//	 id, number
//	 id, id
// ...

ARITHMETIC_ARGS<op> = (NUMBER % (NUMBER
			TAB .UF(*op " " % ", " * .NL)
		| ID
			TAB .UF(*op " " % ", @" * .NL)
		| "[" (ARITHMETIC | FUNC_CALL) "]"
			TAB .UF(*op " " % ", $" .NL)
		| DEREFERENCE
			TAB .UF(*op " " % ", $" .NL)
		| STRING
			TAB .UF(*op " " % ", " * .NL)))
	| ("[" (ARITHMETIC | FUNC_CALL) "]" (NUMBER
			TAB .UF(*op " $, " * .NL)
		| ID
			TAB .UF(*op " $, @" * .NL)
		| "[" (ARITHMETIC | FUNC_CALL) "]"
			TAB .UF(*op " $, $" .NL)
		| DEREFERENCE
			TAB .UF(*op " $, $" .NL)
		| STRING
			TAB .UF(*op " $, " * .NL)))
	| (ID % (NUMBER
			TAB .UF(*op " @" % ", " * .NL)
		| ID
			TAB .UF(*op " @" % ", @" * .NL)
		| "[" (ARITHMETIC | FUNC_CALL) "]"
			TAB .UF(*op " @" % ", $" .NL)
		| DEREFERENCE
			TAB .UF(*op " @" % ", $" .NL)
		| STRING
			TAB .UF(*op " @" % ", " * .NL)))
	| (DEREFERENCE (NUMBER
			TAB .UF(*op " $, " * .NL)
		| ID
			TAB .UF(*op " $, @" * .NL)
		| "[" (ARITHMETIC | FUNC_CALL) "]"
			TAB .UF(*op " $, $" .NL)
		| DEREFERENCE
			TAB .UF(*op " $, $" .NL)
		| STRING
			TAB .UF(*op " $, " * .NL)));

// --------------------------------- return ------------------------------------

RETURN = "return" ((NUMBER TAB .UF("%ret " * .NL))
	| (STRING 
			TAB .UF("%ret " * .NL))
	| ID
			TAB .UF("%ret @" * .NL)
	| DEREFERENCE
		TAB .UF("%ret $" .NL)
	| "[" (FUNC_CALL | ARITHMETIC) "]"
		TAB .UF("%ret $" .NL));

// ---------------------------------- while ------------------------------------

WHILE = "while" "["
	TAB .UF("while (" .NL)
	.DIRECT("inc dword [indent]")
	(FUNC_CALL | ARITHMETIC)
	.DIRECT("dec dword [indent]")
	TAB .UF(") {" .NL) "]"
	.DIRECT("inc dword [indent]")
	$BODY
	.DIRECT("dec dword [indent]")
	TAB .UF("}" .NL);

// ----------------------------------- if --------------------------------------

IF = "if" "[" 
	TAB .UF("if (" .NL)
	.DIRECT("inc dword [indent]")
	(FUNC_CALL | ARITHMETIC)
	.DIRECT("dec dword [indent]")
	TAB .UF(") {" .NL) "]"
	.DIRECT("inc dword [indent]")
	$BODY
	.DIRECT("dec dword [indent]")
	TAB .UF("}" .NL);

// --------------------------------- if/else -----------------------------------

IF_ELSE = "if/else" "[" (FUNC_CALL | ARITHMETIC)
	TAB .UF("cmp eax, 1" .NL)
	TAB .UF("jne " *1 .NL) "]"
	"[" $BODY "]"
	TAB .UF("jmp " *2 .NL)
	.UF(*1 ":" .NL)
	"[" $BODY "]"
	.UF(*2 ":" .NL);

// ----------------------------------- asm -------------------------------------

ASM = "asm" RAW TAB .UF(* .NL);

MOV = "mov" ID % (
	(ID | DEREFERENCE | "[" (FUNC_CALL | ARITHMETIC) "]")
		TAB .UF("mov " % ", eax" .NL)
	| NUMBER
		TAB .UF("mov " % ", " * .NL));

// --------------------------------- define ------------------------------------

DEFINE = "define" ID % (
	(NUMBER
		TAB .UF("%var i32 @" % ", " * .NL))
	| (STRING
		TAB .UF("%var i32 @" % ", " * .NL))
	| (ID
		TAB .UF("%var i32 @" % ", @" * .NL))
	| (DEREFERENCE
		TAB .UF("%var i32 @" % ", $" .NL))
	| ("[" (FUNC_CALL | ARITHMETIC) "]"
		TAB .UF("%var i32 @" % ", $" .NL))
);

// ----------------------------------- set -------------------------------------

SET = "set!" ID % (
	(NUMBER 
		TAB .UF("%set @" % ", " * .NL))
	| (STRING 
		TAB .UF("%set @" % ", " * .NL))
	| (ID 
		TAB .UF("%set @" % ", @" * .NL))
	| (DEREFERENCE
		TAB .UF("%set @" % ", $" .NL))
	| ("[" (FUNC_CALL | ARITHMETIC) "]"
		TAB .UF("%set @" % ", $" .NL))
);

// ------------------------------- Dereference ---------------------------------

DEREFERENCE = "&[" (FUNC_CALL | ARITHMETIC) 
	TAB .UF("%deref/dword $" .NL) "]"
| "&1[" (FUNC_CALL | ARITHMETIC)
	TAB .UF("%deref/byte $" .NL) "]"
| "&2[" (FUNC_CALL | ARITHMETIC)
	TAB .UF("%deref/word $" .NL) "]"
| "&" (ID
	TAB .UF("%deref/dword @" * .NL)
	| DEREFERENCE 
		TAB .UF("%deref/dword $" .NL));

// --------------------------------- defunc ------------------------------------

DEFUNC = "defunc" "[" ID
	.DIRECT("inc dword [indent]")
	.UF("fn " * "(")
	// Outputs the arguments as comma delimited list
	// e.g. `i32 @a, i32 @b, i32 @c`
	$((ID
		.UF("i32 @" * ""))
		($(ID
		.UF(", i32 @" *)) | .EMPTY))
	.UF(") {" .NL)
	"]"
		$(BODY)
	TAB .UF("%ret" .NL)
	.UF("}" .NL .NL)
	.DIRECT("dec dword [indent]");

// ------------------------------ Function Call --------------------------------

FUNC_CALL = ID % .DIRECT("inc dword [call_arg_count]") $(CALL_ARG)
.DIRECT("mov esi, dword [call_arg_count]")
.DIRECT("mov edi, call_arg_count_vector")
.DIRECT("call vector_push")
.DIRECT("mov dword [call_arg_count], 0")
.DIRECT("mov esi, call_arg_count_vector")
.DIRECT("call vector_pop")
.DIRECT("push eax")
.DIRECT("mov edi, str_vector_8192")
.DIRECT("mov esi, eax")
.DIRECT("call vector_reverse_n_string")
TAB
.DIRECT("pop eax")
.DIRECT(".loop:")
.DIRECT("push eax")
.UF(% " ")
.DIRECT("pop eax")
.DIRECT("dec eax")
.DIRECT("cmp eax, 0")
.DIRECT("je .loop_end")
.DIRECT("jmp .loop")
.DIRECT(".loop_end:")
.UF(.NL)
;

CALL_ARG = NUMBER % .DIRECT("inc dword [call_arg_count]")
	| "["
	.DIRECT("section .data")
	.DIRECT("dollar_sign db '$', 0x00")
	.DIRECT("section .text")
	.DIRECT("mov edi, str_vector_8192")
	.DIRECT("mov esi, dollar_sign")
	.DIRECT("call vector_push_string_mm32")
	.DIRECT("mov esi, dword [call_arg_count]")
	.DIRECT("mov edi, call_arg_count_vector")
	.DIRECT("call vector_push")
	.DIRECT("mov dword [call_arg_count], 0")
	(FUNC_CALL)
	.DIRECT("mov esi, call_arg_count_vector")
	.DIRECT("call vector_pop")
	.DIRECT("mov dword [call_arg_count], eax")
	.DIRECT("add dword [call_arg_count], 1")
	"]";

	// add 2, 3
	// add 1, $
	// [+ 1 [+ 2 3]]

// -------------------------------- Comments -----------------------------------

COMMENT = "//" .NOT 10;

// --------------------------------- Output ------------------------------------

TAB = 
.DIRECT("xor ecx, ecx")
.DIRECT("mov eax, dword [indent]")
.DIRECT(".loop:")
.DIRECT("cmp eax, ecx")
.DIRECT("je .loop_end")
.DIRECT("inc ecx")
.UF(.TB)
.DIRECT("jmp .loop")
.DIRECT(".loop_end:");

.TOKENS

// Remove any leading whitespace
PREFIX = $.ANY(32!9!13!10);

// Match numbers (sequence of digits)
NUMBER = PREFIX .TOKEN DIGIT $DIGIT .DELTOK;

// Match any digit
DIGIT  = .ANY(48:57);

// Match any sequence of characters and digits, may not start with a digit.
ID     = PREFIX .TOKEN ALPHA $(ALPHA | DIGIT) .DELTOK;

// Matches any uppercase or lowercase character as well as underscore
ALPHA  = .ANY(65:90!95!97:122) ;

// Matches anything but double quotes that is enclosed by double quotes.
// e.g. "hello world" but not "awd "inner" "
STRING = PREFIX .TOKEN .ANY(34) $.ANYBUT(13!10!34) .ANY(34) .DELTOK;

// Same as STRING but does not capture the double quotes.
RAW 	 = PREFIX .ANY(34) .TOKEN $.ANYBUT(13!10!34) .DELTOK .ANY(34);