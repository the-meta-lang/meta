.SYNTAX PROGRAM

PROGRAM = 
.LABEL("%define MAX_INPUT_LENGTH 65536")
.LABEL("%include './lib/asm_macros.asm'")
	$((".TOKENS"
		.LABEL("; -- Tokens --")
			$(TOKEN_DEFINITION | COMMENT))
		| (".SYNTAX" ID
		.LABEL("section .text")
			->("global _start")
		.LABEL("_start:")
			->("mov esi, 0")
			->("call premalloc")
			->("call _read_file_argument")
			->("call _read_file")
			->("push ebp")
			->("mov ebp, esp")
			->("call " *)
			->("pop ebp")
			->("mov eax, 1")
			->("mov ebx, 0")
			->("int 0x80")
  	$(DEFINITION | IMPORT_STATEMENT | COMMENT)));

// -------------------------------- Includes -----------------------------------

IMPORT_STATEMENT = "import" RAW ";" 
	.DIRECT("mov esi, last_match")
	.DIRECT("call import_meta_file_mm32")
	.DIRECT("mov byte [eswitch], 0");

// --------------------------------- Output ------------------------------------

OUT1 = "*1" ->("call gn1")
	| "*2" ->("call gn2")
	| "*3" ->("call gn3")
	| "*4" ->("call gn4")
	| "*" ->("call copy_last_match")
	| "%" ->("mov edi, str_vector_8192")
				->("call vector_pop_string")
				->("call print_mm32")
	| STRING ->("print " *);

OUT_IMMEDIATE = RAW ->(*);

OUTPUT = ("->" "(" $(OUT1) ")" ->("call newline")
		| ".LABEL" ->("call label") "(" $(OUT1) ")" ->("call newline") 
		| ".RS" "(" $ OUT1 ")")
		| ".DIRECT" "(" $ OUT_IMMEDIATE ")";

EX3 = ID 
			->("call vstack_clear")
			->("call " *)
			->("call vstack_restore")
	| STRING ->("test_input_string" *)
	| ".RET"						->("ret")
	| ".NOT" (STRING | NUMBER) ->("match_not " *)
	| "%"
		->("mov edi, str_vector_8192")
		->("mov esi, last_match")
		->("call vector_push_string_mm32")
	| "(" EX1 ")"
	| ".EMPTY" ->("mov byte [eswitch], 0")
	| "$<" NUMBER 
			.LABEL("section .data")
				->("MIN_ITER_" *3 " dd " *)
			(":" NUMBER
				->("MAX_ITER_" *3 " dd " *)
			| .EMPTY 
				->("MAX_ITER_" *3 " dd 0xFFFFFFFF")) ">"
			.LABEL("section .text")
				->("xor ecx, ecx")
			.LABEL(*1 ":")
			->("push ecx") 
				EX3
			->("pop ecx")
			->("cmp ecx, dword [MAX_ITER_" *3 "]")
			->("jg " *2)
			->("cmp ecx, dword [MIN_ITER_" *3 "]")
			->("jl " *1)
			->("inc ecx")
			->("cmp byte [eswitch], 0")
			->("je " *1)
			.LABEL(*2 ":")
			->("mov byte [eswitch], 0")
	| "$" .LABEL(*1 ":") EX3
			->("cmp byte [eswitch], 0")
			->("je " *1)
			->("mov byte [eswitch], 0")

	// ----------------------- Tree generation semantics --------------------------
	// Capture the last match as a tree node without childnodes
	// e.g. `ID ::address` captures a node called `address` with the string value of `$(ID)`
	| ("::" ID ->("; Capture " * " as single node")
		// Capture a tree node with `NUMBER` childnodes which are the captures in reverse order.
		// e.g. :ADD<2> captures the `ADD` node with 2 childnodes inferred from the last 2 matches.
		| ":" ID "<" NUMBER ">")

	// ------------------------------ Backtracking --------------------------------
	| "{" EX1 $("|" EX1) "}"
	| COMMENT;

EX2 = (EX3 
	->("cmp byte [eswitch], 1")
	->("je " *1) | OUTPUT) $ (EX3 
	->("cmp byte [eswitch], 1")
	->("je terminate_program") | OUTPUT) .LABEL(*1 ":");

EX1 = EX2 $ ("|" 
	->("cmp byte [eswitch], 0")
	->("je " *1) EX2) .LABEL(*1 ":");

DEFINITION = ID .LABEL(* ":") "=" EX1 ";" ->("ret");

// --------------------------------- Tokens ------------------------------------

TOKEN_DEFINITION = ID
	.LABEL(* ":") "=" TX1 ";" ->("ret");

TX1 = TX2 $("|" 
				->("cmp byte [eswitch], 0")
				->("je " *1) TX2) 
      .LABEL(*1 ":") ;

TX2 = TX3
	->("cmp byte [eswitch], 1")
	->("je " *1)
			// Return from rule if error switch = 1
      $(TX3 
				->("cmp byte [eswitch], 1")
				->("je " *1))
      .LABEL(*1 ":");

// Capture the next incoming tokens until .DELTOK
TX3 = (".TOKEN"
					// Capture the incoming token
					->("mov byte [tflag], 1")
					->("call clear_token")
				| ".DELTOK"
					// Stop capturing the token
					->("mov byte [tflag], 0")
				| "$" .LABEL(*1 ":") TX3 
					->("cmp byte [eswitch], 0")
					->("je " *1)) 
        ->("mov byte [eswitch], 0")
			| ".ANYBUT(" CX1 ")"
				// Negate the error switch
				->("mov al, byte [eswitch]")
				->("xor al, 1")
				->("mov byte [eswitch], al")
				->("call scan_or_parse")
			| ".ANY(" CX1 ")"
				->("call scan_or_parse")
			// Reserve a string that may not be used in a token.
			// Helpful when identifiers could be named the same as a keyword e.g. "if"
			| ".RESERVED(" $(STRING 
					->("test_input_string " *)
					->("mov al, byte [eswitch]")
					->("xor al, 1")
					->("mov byte [eswitch], al")) ")"
			| ID
				->("call " *)
			| "(" TX1 ")";

// OR
CX1 = CX2 $("!"
				->("cmp byte [eswitch], 0")
				->("je " *1) CX2)
			.LABEL(*1 ":");

// Match a range of characters
// FROM : TO
CX2 = CX3 (":" 
				->("mov edi, " *)
				->("call test_char_greater_equal")
				->("cmp byte [eswitch], 0")
				->("jne " *1) 
      CX3
				->("mov edi, " *)
        ->("call test_char_less_equal")
			.LABEL(*1 ":")
			| .EMPTY 
				->("mov edi, " *)
				->("call test_char_equal"));

CX3 = NUMBER;

// -------------------------------- Comments -----------------------------------

COMMENT = "//" .NOT 10;

// ---------------------------- Token Definitions ------------------------------

.TOKENS

// Remove any leading whitespace
PREFIX = $.ANY(32!9!13!10);

// Match numbers (sequence of digits)
NUMBER = PREFIX .TOKEN DIGIT $DIGIT .DELTOK;

// Match any digit
DIGIT  = .ANY(48:57);

// Match any sequence of characters and digits, may not start with a digit.
ID     = PREFIX .RESERVED("import") .TOKEN ALPHA $(ALPHA | DIGIT) .DELTOK;

// Matches any uppercase or lowercase character as well as underscore
ALPHA  = .ANY(65:90!95!97:122) ;

// Matches anything but double quotes that is enclosed by double quotes.
// e.g. "hello world" but not "awd "inner" "
STRING = PREFIX .TOKEN .ANY(34) $.ANYBUT(13!10!34) .ANY(34) .DELTOK;

// Same as STRING but does not capture the double quotes.
RAW 	 = PREFIX .ANY(34) .TOKEN $.ANYBUT(13!10!34) .DELTOK .ANY(34);

.END