.DATA

last_match = { 512 };
line = 0;
// Symbol Table
// TODO: Fehler wird geworfen, weil last_match nicht definiert wird im symbol table
ST = { 65536 };
// Symbol Table Offset
STO = 4;

GLOBALS = { 65536 };

// The current argument counter for the function call
ARG_NUM = 0;

VAR_IN_BODY = 0;

.CODE

hello = [[awd] [set line 2]]

.SYNTAX PROGRAM

PROGRAM = 
.LABEL("%define MAX_INPUT_LENGTH 65536")
.LABEL("%include './lib/asm_macros.asm'")
	$(
		(".DATA" 
			$(DATA_DEFINITION | COMMENT))
	 | (".CODE" 
		.LABEL("section .text")
	 		$(CODE_DEFINITION | COMMENT))
	 | (".SYNTAX" .ID
		.LABEL("section .text")
			->("global _start")
		.LABEL("_start:")
			->("call _read_file_argument")
			->("call _read_file")
			->("push ebp")
			->("mov ebp, esp")
			->("call " *)
			->("pop ebp")
			->("mov eax, 1")
			->("mov ebx, 0")
			->("int 0x80")
  	$(DEFINITION | INCLUDE_STATEMENT | COMMENT) ".END"));

INCLUDE_STATEMENT = ".INCLUDE" .STRING_RAW ";" .DIRECT("mov esi, last_match") .DIRECT("call import_meta_file_mm32") .DIRECT("call set_true");

DATA_DEFINITION = .ID [hash-set *GLOBALS *last_match 1] [set STO [+ STO 4]] %> %> "=" DATA_TYPE ";";

DATA_TYPE = (("{" 
	.LABEL("section .bss")
		.NUMBER ->(% " resb " *) "}")
	| (.STRING .LABEL("section .data") ->(% " db " * ", 0x00"))
	| (.NUMBER .LABEL("section .data") ->(% " dd " *)));

OUT1 = "*1" ->("call gn1")
	| "*2" ->("call gn2")
	| "*3" ->("call gn3")
	| "*4" ->("call gn4")
	| "*" ->("call copy_last_match")
	| "%" ->("mov edi, str_vector_8192")
				->("call vector_pop_string")
				->("call print_mm32")
	| BRACKET_EXPR_WRAPPER
	| .STRING ->("print " *);

OUT_IMMEDIATE = .STRING_RAW ->(*);

OUTPUT = ("->" "(" $(OUT1) ")" ->("call newline") [set line [+ line 1]]
		| ".LABEL" ->("call label") "(" $(OUT1) ")" ->("call newline") 
		| ".RS" "(" $ OUT1 ")")
		| ".DIRECT" "(" $ OUT_IMMEDIATE ")";

EX3 = .ID ->("call vstack_clear") ->("call " *) ->("call vstack_restore")
	| .STRING           ->("test_input_string " *)
	| ".ID"             ->("call test_for_id")
	| ".RET"						->("ret")
	| ".NOT" (.STRING | .NUMBER) ->("match_not " *)
	| ".NUMBER"         ->("call test_for_number")
	| ".STRING_RAW"			->("call test_for_string_raw")
	| ".STRING"         ->("call test_for_string")
	| "%>"
		->("mov edi, str_vector_8192")
		->("mov esi, last_match")
		->("call vector_push_string_mm32")
	| "(" EX1 ")"
	| BRACKET_EXPR_WRAPPER
	| ".EMPTY" ->("call set_true")
	| "$" .LABEL(*1 ":") EX3 ->("je " *1) ->("call set_true")
	| COMMENT;

EX2 = (EX3 ->("jne " *1) | OUTPUT) $ (EX3 ->("mov edi, " [print_int line]) ->("jne terminate_program ; " [print_int line]) [set line [+ line 1]]  | OUTPUT) .LABEL(*1 ":");

EX1 = EX2 $ ("|" ->("je " *1) EX2) .LABEL(*1 ":");

BRACKET_EXPR_WRAPPER = "[" (("<<" [set ARG_NUM 0] BRACKET_ARG
		->("cmp eax, 0"))
	// Set the flags according to the result of the last operation
	| (->("pushfd") ->("push eax") BRACKET_EXPR ->("pop eax") ->("popfd"))) "]";

BRACKET_EXPR = ("+" [set ARG_NUM 0] BRACKET_ARG [set ARG_NUM 1] BRACKET_ARG
		->("add eax, ebx")) 
	| ("-" [set ARG_NUM 0] BRACKET_ARG [set ARG_NUM 1] BRACKET_ARG
		->("sub eax, ebx"))
	| ("*" [set ARG_NUM 0] BRACKET_ARG [set ARG_NUM 1] BRACKET_ARG
		->("mul ebx")) 
	| ("/" [set ARG_NUM 0] BRACKET_ARG [set ARG_NUM 1] BRACKET_ARG
		->("idiv eax, ebx"))
	| ("set" .ID %> [set ARG_NUM 0] BRACKET_ARG
		->("mov dword [" % "], eax"))
	| ("if" BRACKET_ARG 
			->("pop eax") 
			->("cmp eax, 0") 
			->("jne " *1)
				BRACKET_ARG
			->("jmp " *2)
			.LABEL(*1 ":")
				BRACKET_ARG)
			.LABEL(*2 ":")
	| ("hash-set" FN_CALL_ARG
		->("call hash_set"))
	| ("hash-get" FN_CALL_ARG
		->("call hash_get"))
	// Print the result of the last operation
	| (">>" [set ARG_NUM 0] FN_CALL_ARG
		->("call print_int"))
	| ("<>" [set ARG_NUM 0] BRACKET_ARG)
	| (.ID %> FN_CALL_ARG ->("call " %));


// Assignment order
// edi - 1
// esi - 2
// edx - 3
// ecx - 4
FN_CALL_ARG = 
$((("[" BRACKET_EXPR "]" ->("mov edi, eax"))
	| (.NUMBER ->("mov edi, " *))
	| (.ID ([<< [hash-get *GLOBALS *last_match]] ->("mov edi, dword [ebp+" [>> [hash-get *ST *last_match]] "]") ->("mov edi, dword [edi]") | ->("mov edi, dword [" * "]") .DIRECT("call set_true")))
		| ("*" .ID 
			([<< [hash-get *GLOBALS *last_match]] ->("mov edi, dword [ebp+" [>> [hash-get *ST *last_match]] "]") | ->("mov edi, " *) .DIRECT("call set_true")))
	| (.STRING 
		.LABEL("section .data")
			->(*3 " db " * ", 0x00")
		.LABEL("section .text")
			->("mov edi, " *3)))
	$((("[" BRACKET_EXPR "]" ->("mov esi, eax"))
		| (.NUMBER ->("mov esi, " *))
		| (.ID ([<< [hash-get *GLOBALS *last_match]] ->("mov esi, dword [ebp+" [>> [hash-get *ST *last_match]] "]") ->("mov esi, dword [esi]") | ->("mov esi, dword [" * "]") .DIRECT("call set_true")))
		| ("*" .ID 
			([<< [hash-get *GLOBALS *last_match]] ->("mov esi, dword [ebp+" [>> [hash-get *ST *last_match]] "]") | ->("mov esi, " *) .DIRECT("call set_true")))
		| (.STRING 
			.LABEL("section .data")
				->(*3 " db " * ", 0x00")
			.LABEL("section .text")
				->("mov esi, " *3)))
		$((("[" BRACKET_EXPR "]" ->("mov edx, eax"))
			| (.NUMBER ->("mov edx, " *))
			| (.ID ([<< [hash-get *GLOBALS *last_match]] ->("mov edx, dword [ebp+" [>> [hash-get *ST *last_match]] "]") ->("mov edx, dword [edx]") | ->("mov edx, dword [" * "]") .DIRECT("call set_true")))
		| ("*" .ID 
			([<< [hash-get *GLOBALS *last_match]] ->("mov edx, dword [ebp+" [>> [hash-get *ST *last_match]] "]") | ->("mov edx, " *) .DIRECT("call set_true")))
			| (.STRING 
				.LABEL("section .data")
					->(*3 " db " * ", 0x00")
				.LABEL("section .text")
					->("mov edx, " *3))))));

BRACKET_ARG = ("[" BRACKET_EXPR "]")
	| (.NUMBER ([<< ARG_NUM] ->("mov eax, " *) | ->("mov ebx, " *) .DIRECT("call set_true")))
	| (.ID ([<< ARG_NUM] 
			([<< [hash-get *GLOBALS *last_match]] 
				->("mov eax, dword [ebp+" [>> [hash-get *ST *last_match]] "]") 
				->("mov eax, dword [eax]")
			| ->("mov eax, dword [" * "]") .DIRECT("call set_true")) 
		| ([<< [hash-get *GLOBALS *last_match]] 
				->("mov ebx, dword [ebp+" [>> [hash-get *ST *last_match]] "]") 
				->("mov ebx, dword [eax]")
			| ->("mov ebx, dword [" * "]") .DIRECT("call set_true"))))

	| ("*" .ID ([<< ARG_NUM] ([<< [hash-get *GLOBALS *last_match]] ->("mov eax, dword [ebp+" [>> [hash-get *ST *last_match]] "]") | ->("mov eax, " *) .DIRECT("call set_true"))  | ([<< [hash-get *GLOBALS *last_match]] ->("mov ebx, dword [ebp+" [>> [hash-get *ST *last_match]] "]") | ->("mov ebx, " *) .DIRECT("call set_true"))))
	| (.STRING 
	.LABEL("section .data")
		->(*3 " db " * ", 0x00")
	.LABEL("section .text")
		([<< ARG_NUM] ->("mov eax, " *3) | ->("mov ebx, " *3) .DIRECT("call set_true")));

// Code Definitions

CODE_DEFINITION = .ID .LABEL(* ":") "=" "["
	// Arguments
	->("push ebp")
	->("mov ebp, esp") 
	"[" 
		$(.ID [hash-set *ST *last_match [set STO [+ STO 4]]] [set VAR_IN_BODY [+ VAR_IN_BODY 1]] ->("mov dword [ebp+" [>> STO] "], edi")
			$(.ID [hash-set *ST *last_match [set STO [+ STO 4]]] [set VAR_IN_BODY [+ VAR_IN_BODY 1]] ->("mov dword [ebp+" [>> STO] "], esi")
				$(.ID [hash-set *ST *last_match [set STO [+ STO 4]]] [set VAR_IN_BODY [+ VAR_IN_BODY 1]] ->("mov dword [ebp+" [>> STO] "], edx") 
					$(.ID [hash-set *ST *last_match [set STO [+ STO 4]]] [set VAR_IN_BODY [+ VAR_IN_BODY 1]] ->("mov dword [ebp+" [>> STO] "], ecx")
						$(.ID [hash-set *ST *last_match [set STO [+ STO 4]]] [set VAR_IN_BODY [+ VAR_IN_BODY 1]])))))
	"]"
	// Code
	// BRACKET_EXPR will leave the result on the stack
	$("[" BRACKET_EXPR "]")
	->("pop ebp")
	->("ret") 
	[set STO [- STO [* 4 VAR_IN_BODY]]]
	[set VAR_IN_BODY 0]
	"]";

DEFINITION = .ID .LABEL(* ":") "=" EX1 ";" ->("ret");

COMMENT = "//" .NOT 10;

.END
