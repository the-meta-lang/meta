.SYNTAX PROGRAM

PROGRAM = 
.LABEL("%define MAX_INPUT_LENGTH 65536")
.LABEL("%include './lib/asm_macros.asm'")
.LABEL("section .text")
	->("global _start")
	$((".TOKENS"
		.LABEL("; -- Tokens --")
			$(TOKEN_DEFINITION | COMMENT))
		| (".CODE"
		.LABEL("; -- Code --")
			$(LISP | COMMENT))
		| (".SYNTAX" ID
		.LABEL("_start:")
			->("mov esi, 0")
			->("call premalloc")
			->("call _read_file_argument")
			->("call _read_file")
			->("push ebp")
			->("mov ebp, esp")
			->("call " *)
			->("pop ebp")
			->("mov edi, outbuff")
			->("call print_mm32")
			->("mov eax, 1")
			->("mov ebx, 0")
			->("int 0x80")
  	$(DEFINITION | IMPORT_STATEMENT | COMMENT)));

// ---------------------------------- Lisp -------------------------------------

LISP = "[" 
	(LISP_DEFINE
	| ("defunc" "[" LISP_ID
		.LABEL(* ":")
			->("push ebp")
			->("mov ebp, esp") 
		$(LISP_ID) "]" LISP
			->("pop eax")
			->("mov esp, ebp")
			->("pop ebp")
			->("ret"))
	| ("set" LISP_ID % LISP_ARG
			->("pop eax")
			->("mov dword [" % "], eax")
			->("push eax"))
	| ("+" LISP_ARG LISP_ARG
			->("pop eax")
			->("pop ebx")
			->("add eax, ebx")
			->("push eax"))
	// Raw assembly instructions
	| ("asm" RAW
			->(*))
	| LISP_FN_CALL)
"]";

LISP_DEFINE = "define" LISP_ID % %
		->("; -- Define " * " --") (
	(NUMBER
	.LABEL("section .data")
		->(% " dd " *)
	.LABEL("section .text")
		->("mov eax, " %))
	| (STRING 
	.LABEL("section .data")
		->(% " db " * ", 0x00")
	.LABEL("section .text")
		->("mov eax, " %))
	| (LISP_ID
		.LABEL("section .data")
			->(% " dd 0")
		.LABEL("section .text")
			->("mov eax, " *)
			->("mov dword [" % "], eax"))
	| ("&" LISP_ID
	.LABEL("section .data")
		->(% " dd 0")
	.LABEL("section .text")
		->("mov eax, [" * "]")
		->("mov dword [" % "], eax"))
	| (LISP
	.LABEL("section .data")
		->(% " dd 0")
	.LABEL("section .text")
		->("mov dword [" % "], eax"))
);

LISP_FN_CALL = LISP_ID % LISP_CALL_ARGS
	->("call " %);

LISP_CALL_ARGS = $(((NUMBER ->("mov esi, " *))
	| (STRING 
		.LABEL("section .data")
			->(*3 " db " * ", 0x00")
		.LABEL("section .text")
			->("mov esi, " *3))
	| (LISP_ID 
		->("mov esi, " *))
	| ("&" LISP_ID
		->("mov esi, [" * "]"))
	| LISP
		->("pop esi"))
	$(((NUMBER ->("mov edi, " *))
		| (STRING 
			.LABEL("section .data")
				->(*3 " db " * ", 0x00")
			.LABEL("section .text")
				->("mov edi, " *3))
		| (LISP_ID 
			->("mov edi, " *))
		| ("&" LISP_ID
			->("mov edi, [" * "]"))
		| LISP
			->("pop edi"))
		$(((NUMBER ->("mov edx, " *))
		| (STRING 
			.LABEL("section .data")
				->(*3 " db " * ", 0x00")
			.LABEL("section .text")
				->("mov edx, " *3))
		| (LISP_ID 
			->("mov edx, " *))
		| ("&" LISP_ID
			->("mov edx, [" * "]"))
		| LISP
			->("pop edx")))));

LISP_ARG = NUMBER ->("push " *)
	| STRING 
		.LABEL("section .data")
			->(*3 " db " * ", 0x00")
		.LABEL("section .text")
			->("push " *3)
	| LISP_ID 
		->("push " *)
	| "&" LISP_ID
		->("push [" * "]")
	| LISP;

// -------------------------------- Includes -----------------------------------

IMPORT_STATEMENT = "import" RAW ";" 
	.DIRECT("mov esi, last_match")
	.DIRECT("call import_meta_file_mm32")
	.DIRECT("mov byte [eswitch], 0");

// --------------------------------- Output ------------------------------------

OUT1 = "*1" ->("call gn1")
	| "*2" ->("call gn2")
	| "*3" ->("call gn3")
	| "*4" ->("call gn4")
	| "*" (ID
			->("mov esi, " *)
			->("mov edi, outbuff")
			->("add edi, [outbuff_offset]")
			->("call buffc")
			->("add dword [outbuff_offset], eax")
		| .EMPTY ->("call copy_last_match")
	)
	| "#" ID
		->("mov esi, dword [" * "]")
		->("mov edi, outbuff")
		->("add edi, dword [outbuff_offset]")
		->("call inttostr")
		->("add dword [outbuff_offset], eax")
	| "%" ->("mov edi, str_vector_8192")
				->("call vector_pop_string")
				->("mov esi, eax")
				->("mov edi, outbuff")
				->("add edi, [outbuff_offset]")
				->("call buffc")
				->("add dword [outbuff_offset], eax")
	| STRING ->("print " *);

OUT_IMMEDIATE = RAW ->(*);

OUTPUT = ("->" "(" $(OUT1) ")" ->("call newline")
		| ".LABEL" ->("call label") "(" $(OUT1) ")" ->("call newline") 
		| ".RS" "(" $(OUT1) ")")
		| ".DIRECT" "(" $ OUT_IMMEDIATE ")"
		| ".ERROR"
			// We're gonna kill the program, so why not just write into the buffer directly...
			->("mov dword [outbuff_offset], 0")
			"(" $(OUT1) ")"
			->("mov edi, outbuff")
			->("call print_mm32")
			->("mov eax, 1")
			->("mov ebx, 1")
			->("int 0x80");

EX3 = ID 
			->("call vstack_clear")
			->("call " *)
			->("call vstack_restore")
	| STRING ->("test_input_string " *)
	| ".RET"						->("ret")
	| ".NOT" (STRING | NUMBER) ->("match_not " *)
	| "%"
		->("mov edi, str_vector_8192")
		->("mov esi, last_match")
		->("call vector_push_string_mm32")
	| "(" EX1 ")"
	| ".EMPTY" ->("mov byte [eswitch], 0")
	| "$<" NUMBER 
			.LABEL("section .data")
				->("MIN_ITER_" *3 " dd " *)
			(":" NUMBER
				->("MAX_ITER_" *3 " dd " *)
			| .EMPTY 
				->("MAX_ITER_" *3 " dd 0xFFFFFFFF")) ">"
			.LABEL("section .text")
				->("xor ecx, ecx")
			.LABEL(*1 ":")
			->("push ecx") 
				EX3
			->("pop ecx")
			->("cmp ecx, dword [MAX_ITER_" *3 "]")
			->("jg " *2)
			->("cmp ecx, dword [MIN_ITER_" *3 "]")
			->("jl " *1)
			->("inc ecx")
			->("cmp byte [eswitch], 0")
			->("je " *1)
			.LABEL(*2 ":")
			->("mov byte [eswitch], 0")
	| "$" .LABEL(*1 ":") EX3
			->("cmp byte [eswitch], 0")
			->("je " *1)
			->("mov byte [eswitch], 0")
	| LISP

	// ----------------------- Tree generation semantics --------------------------
	// Capture the last match as a tree node without childnodes
	// e.g. `ID ::address` captures a node called `address` with the string value of `$(ID)`
	| ("::" ID ->("; Capture " * " as single node")
		// Capture a tree node with `NUMBER` childnodes which are the captures in reverse order.
		// e.g. :ADD<2> captures the `ADD` node with 2 childnodes inferred from the last 2 matches.
		| ":" ID "<" NUMBER ">")

	// ------------------------------ Backtracking --------------------------------
	| "{"
			// Store backtracking position
			->("call backtrack_store")
		EX1 $("/"
				// If we didn't encounter an error we can simply exit the loop
				// and clear the backtracking information.
				// TODO: Maybe change to `pflag`
				->("cmp byte [eswitch], 0")
				->("je " *1)
				// We encountered an error
				// Let's restore the backtracking position
				->("call backtrack_restore")
			EX1) "}"
			->("cmp byte [eswitch], 0")
			->("je " *1)
			// We exited with an error, let's backtrack
			->("call backtrack_restore")
		.LABEL(*1 ":")
			->("call backtrack_clear")
	| COMMENT;

EX2 = (EX3 
	->("cmp byte [eswitch], 1")
	->("je " *1) | OUTPUT) $ (EX3 
	->("cmp byte [eswitch], 1")
	// NOTE: Terminating here doesn't work with backtracking
	// TODO: When using backtracking, this should be `je *1`
	->("je terminate_program") | OUTPUT)
	.LABEL(*1 ":");

EX1 = EX2 $ ("|" 
	->("cmp byte [eswitch], 0")
	->("je " *1) EX2) .LABEL(*1 ":");

DEFINITION = ID .LABEL(* ":") "=" EX1 (";" | .ERROR("Missing semicolon on char: " #input_string_offset)) ->("ret");

// --------------------------------- Tokens ------------------------------------

TOKEN_DEFINITION = ID
	.LABEL(* ":") "=" TX1 ";" ->("ret");

TX1 = TX2 $("|" 
				->("cmp byte [eswitch], 0")
				->("je " *1) TX2) 
      .LABEL(*1 ":") ;

TX2 = TX3
	->("cmp byte [eswitch], 1")
	->("je " *1)
			// Return from rule if error switch = 1
      $(TX3 
				->("cmp byte [eswitch], 1")
				->("je " *1))
      .LABEL(*1 ":");

// Capture the next incoming tokens until .DELTOK
TX3 = (".TOKEN"
					// Capture the incoming token
					->("mov byte [tflag], 1")
					->("call clear_token")
				| ".DELTOK"
					// Stop capturing the token
					->("mov byte [tflag], 0")
				| "$" .LABEL(*1 ":") TX3 
					->("cmp byte [eswitch], 0")
					->("je " *1)) 
        ->("mov byte [eswitch], 0")
			| ".ANYBUT(" CX1 ")"
				// Negate the error switch
				->("mov al, byte [eswitch]")
				->("xor al, 1")
				->("mov byte [eswitch], al")
				->("call scan_or_parse")
			| ".ANY(" CX1 ")"
				->("call scan_or_parse")
			// Reserve a string that may not be used in a token.
			// Helpful when identifiers could be named the same as a keyword e.g. "if"
			| ".RESERVED(" $(STRING 
					->("test_input_string " *)
					->("mov al, byte [eswitch]")
					->("xor al, 1")
					->("mov byte [eswitch], al")) ")"
			| ID
				->("call " *)
			| "(" TX1 ")";

// OR
CX1 = CX2 $("!"
				->("cmp byte [eswitch], 0")
				->("je " *1) CX2)
			.LABEL(*1 ":");

// Match a range of characters
// FROM : TO
CX2 = CX3 (":" 
				->("mov edi, " *)
				->("call test_char_greater_equal")
				->("cmp byte [eswitch], 0")
				->("jne " *1) 
      CX3
				->("mov edi, " *)
        ->("call test_char_less_equal")
			.LABEL(*1 ":")
			| .EMPTY 
				->("mov edi, " *)
				->("call test_char_equal"));

CX3 = NUMBER | STRING;

// -------------------------------- Comments -----------------------------------

COMMENT = "//" .NOT 10;

// ---------------------------- Token Definitions ------------------------------

.TOKENS

// Remove any leading whitespace
PREFIX = $.ANY(32!9!13!10);

// Match numbers (sequence of digits)
NUMBER = PREFIX .TOKEN DIGIT $DIGIT .DELTOK;

// Match any digit
DIGIT  = .ANY(48:57);

// Match any sequence of characters and digits, may not start with a digit.
ID     = PREFIX .RESERVED("import") .TOKEN ALPHA $(ALPHA | DIGIT) .DELTOK;

// Matches any uppercase or lowercase character as well as underscore
ALPHA  = .ANY(65:90!95!97:122) ;

// Matches anything but double quotes that is enclosed by double quotes.
// e.g. "hello world" but not "awd "inner" "
STRING = PREFIX .TOKEN .ANY(34) $.ANYBUT(13!10!34) .ANY(34) .DELTOK;

// Same as STRING but does not capture the double quotes.
RAW 	 = PREFIX .ANY(34) .TOKEN $.ANYBUT(13!10!34) .DELTOK .ANY(34);

// An identifier name for the integrated lisp-like language
// Supports any sequence of characters, digits, question marks, dashes and exclamation marks, may not start with a digit or a special character.
LISP_ID = PREFIX .TOKEN ALPHA $(ALPHA | DIGIT) .DELTOK;
