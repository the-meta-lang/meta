.SYNTAX LISP

LISP =
.DIRECT("section .data")
// Count of arguments that was actually used.
.DIRECT("used_arg_count dd 0")
.DIRECT("push_prefix db 'push dword [ebp', 0x00")
.DIRECT("push_prefix_global db 'push dword [', 0x00")
.DIRECT("fn_arg_num dd 0")
// A boolean set to 1 if we're currently in the global scope.
.DIRECT("is_global db 1")
.DIRECT("loop_counter dd 0")
.DIRECT("section .bss")
.DIRECT("push_buffer resb 128")
.DIRECT("symbol_table resb 262144")
.DIRECT("section .text")
PREAMBLE $(ROOT_BODY) POSTAMBLE;

ROOT_BODY = COMMENT | "[" (DEFUNC | DEFINE | SET | ASMMACRO | WHILE | IF_ELSE | IF | ARITHMETIC | ASM | MOV | FUNC_CALL) "]";

// -------------------------------- Preamble -----------------------------------

PREAMBLE =
	.LABEL("section .text")
		->("global _start")
	.LABEL("_start:")
		->("push ebp")
		->("mov ebp, esp");

POSTAMBLE =
		->("mov esp, ebp")
		->("pop ebp")
		->("mov ebx, eax")
		->("mov eax, 1")
		->("int 0x80");

// ---------------------------------- body -------------------------------------

BODY = COMMENT | "[" (DEFINE | SET | WHILE | IF_ELSE | IF | CONTINUE | BREAK | ARITHMETIC | ASM | MOV | RETURN | FUNC_CALL | BODY) "]";

// ------------------------------ Control Flow ---------------------------------

CONTINUE = "continue" 
	->("jmp " *2);

BREAK = "break" 
	->("jmp " *1);

// --------------------------------- arithmetic --------------------------------

ARITHMETIC = ("+" BINOP_ARGS
		->("add eax, ebx")
		->("push eax")
	| "-" BINOP_ARGS
		->("sub eax, ebx")
		->("push eax")
	| "*" BINOP_ARGS
		->("imul eax, ebx")
		->("push eax")
	| "/" BINOP_ARGS
		->("xor edx, edx")
		->("div ebx")
		->("push eax")
	// Modulo
	| "%" BINOP_ARGS
		->("xor edx, edx")
		->("div ebx")
		->("mov eax, edx")
		->("push eax")
	| "and" BINOP_ARGS
		->("and eax, ebx")
		->("push eax")
	| "or" BINOP_ARGS
		->("or eax, ebx")
		->("push eax")
	| "not" BINOP_ARGS
		->("not eax")
		->("push eax")
	| "<=" BINOP_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("setle al")
		->("push eax")
	| ">=" BINOP_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("setge al")
		->("push eax")
	| "==" BINOP_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("sete al")
		->("push eax")
	| "!=" BINOP_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("setne al")
		->("push eax")
	// Bitwise left-shift
	| "<<" BINOP_ARGS
		->("mov ecx, ebx")
		->("shl eax, cl")
		->("push eax")
	// Bitwise right-shift
	| ">>" BINOP_ARGS
		->("mov ecx, ebx")
		->("shr eax, cl")
		->("push eax")
	// Xor
	| "^" BINOP_ARGS
		->("xor eax, ebx")
		->("push eax")
	| "<" BINOP_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("setl al")
		->("push eax")
	| ">" BINOP_ARGS
		->("cmp eax, ebx")
		->("mov eax, 0")
		->("setg al")
		->("push eax"));

// --------------------------------- return ------------------------------------

RETURN = "return" CALL_ARGS
	->("mov esp, ebp")
	->("pop ebp")
	->("ret");

// ---------------------------------- while ------------------------------------

WHILE = "while" "["
	.LABEL(*2 ":")
		(FUNC_CALL | ARITHMETIC)
	->("cmp eax, 1") 
	->("jne " *1) "]"
		$(BODY)
	->("jmp " *2)
	.LABEL(*1 ":");

// ----------------------------------- if --------------------------------------

IF = "if" "[" (FUNC_CALL | ARITHMETIC)
	->("cmp eax, 1")
	->("jne " *1) "]" $BODY
	.LABEL(*1 ":");

// --------------------------------- if/else -----------------------------------

IF_ELSE = "if/else" "[" (FUNC_CALL | ARITHMETIC)
	->("cmp eax, 1")
	->("jne " *1) "]"
	BODY
	->("jmp " *2)
	.LABEL(*1 ":")
	BODY
	.LABEL(*2 ":");

// ----------------------------- Assembler Macro -------------------------------

ASMMACRO = "asmmacro" "[" ID 
	->("jmp " *1)
	.LABEL(* ":")
		->("push ebp")
		->("mov ebp, esp") $(ID) "]"
	$(RAW ->(*))
		->("mov esp, ebp")
		->("pop ebp")
		->("ret")
	.LABEL(*1 ":");

// ----------------------------------- asm -------------------------------------

ASM = "asm" RAW ->(*);

MOV = "mov" ID % (
	(SYMBOL_TABLE_ID | "[" (FUNC_CALL | ARITHMETIC) "]")
		->("mov " % ", eax")
	| NUMBER
		->("mov " % ", " *));

// --------------------------------- define ------------------------------------

DEFINE = "define" ID % %
	// write the index into the symbol table
	// If we're in the global scope we need to open a data section here
	.DIRECT("cmp byte [is_global], 1")
	.DIRECT("jne define_local")
	// According to the symbol table specification we need to add 0x80000000 (first bit of 32 bit int) to signal a global variable
	// As we don't need positional information for a global, we can ignore adding fn_arg_num or incrementing it
	.DIRECT("mov edx, 0x80000000")
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, last_match")
	.DIRECT("call hash_set")
	.DIRECT("jmp define_end")
	.DIRECT("define_local:")
	.DIRECT("mov edx, dword [fn_arg_num]")
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, last_match")
	.DIRECT("call hash_set")
	.DIRECT("define_end:") (
	(NUMBER
		MOV_INTO ->(* " ; define " %))
	| (STRING 
	.LABEL("section .data")
		->(*3 " db " * ", 0x00")
	.LABEL("section .text")
		MOV_INTO ->(*3 " ; define " %))
	| (SYMBOL_TABLE_ID
		MOV_INTO ->("eax ; define " %))
	| ("[" (FUNC_CALL | ARITHMETIC) "]"
		MOV_INTO ->("eax ; define " %))
) // subtract 4 from the stack pointer so we don't accidentally overwrite the variable
	.DIRECT("cmp byte [is_global], 1")
	.DIRECT("je no_sub")
	.DIRECT("dec dword [fn_arg_num]")
	->("sub esp, 4")
	.DIRECT("no_sub:");

MOV_INTO = 
	// We need to check whether we're in the global scope
	.DIRECT("cmp byte [is_global], 1")
	.DIRECT("jne mov_into_local")
	// If we're in the global scope we need to open a data section here
	.LABEL("section .bss")
	->(% " resd 1")
	.LABEL("section .text")
	.RS("mov dword [" % "], ")
	.DIRECT("jmp mov_end")
	.DIRECT("mov_into_local:")
	.RS("mov dword [ebp")
	// use the symbol table to get the index of the variable
	// then calculate the offset by doing `8 + (arg_count - index) * 4`
	.DIRECT("mov eax, dword [fn_arg_num]") // index is now in eax
	.DIRECT("imul eax, eax, 4") // (arg_count - index) * 4
	.DIRECT("add eax, 8") // 8 + (arg_count - index) * 4
	.DIRECT("mov esi, eax")
	.DIRECT("mov edi, outbuff")
	.DIRECT("add edi, dword [outbuff_offset]")
	.DIRECT("call inttostrsigned")
	.DIRECT("add dword [outbuff_offset], eax")
	.RS("], ")
	.DIRECT("mov_end:");

// ----------------------------------- set -------------------------------------
SET = "set!" ID %<"" *> %<"" *> (
	(NUMBER 
		SET_INTO ->(* " ; set "))
	| (STRING 
	.LABEL("section .data")
		->(*3 " db " * ", 0x00")
	.LABEL("section .text")
		SET_INTO ->(*3 " ; set "))
	| (SYMBOL_TABLE_ID 
		SET_INTO ->("eax ; set "))
	| ("[" (FUNC_CALL | ARITHMETIC) "]"
		SET_INTO ->("eax ; set "))
);

SET_INTO = 
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, str_vector_8192")
	.DIRECT("call vector_pop_string")
	.DIRECT("mov esi, eax")
	.DIRECT("call hash_get") // Variable information now in eax
		// We need to check whether we're in the global scope
	.DIRECT("cmp eax, 0x80000000")
	.DIRECT("jne set_into_local")
	.RS("mov dword [" % "], ")
	.DIRECT("jmp set_into_end")
	.DIRECT("set_into_local:")
	.DIRECT("push eax")
	.RS("mov dword [ebp")
	.DIRECT("pop eax")
	// set the value of the variable
	// we can use the symbol table to get the index of the variable
	// then calculate the offset by doing `8 + (arg_count - index) * 4`
	.DIRECT("imul eax, eax, 4") // (arg_count - index) * 4
	.DIRECT("add eax, 8") // 8 + (arg_count - index) * 4
	.DIRECT("mov esi, eax")
	.DIRECT("mov edi, outbuff")
	.DIRECT("add edi, dword [outbuff_offset]")
	.DIRECT("call inttostrsigned")
	.DIRECT("add dword [outbuff_offset], eax")
	.RS("], ")
	.DIRECT("set_into_end:");

// --------------------------------- defunc ------------------------------------

DEFUNC = "defunc"
	.DIRECT("mov byte [is_global], 0")
	"[" ID
	->("jmp " *1)
	.LABEL(* ":")
		->("push ebp")
		->("mov ebp, esp")
	.DIRECT("mov dword [fn_arg_num], 0")
	$(ID
	// We found a new argument, we need to put it into the symbol table
	// with it's index as a value
	.DIRECT("mov edx, dword [fn_arg_num]")
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, last_match")
	.DIRECT("call hash_set")
	.DIRECT("inc dword [fn_arg_num]"))
	// increase the arg num to `arg_num + 2` to make space for the return address and the old ebp
	// this will make it possible to use `8 + (arg_count - index) * 4` to get the offset of local variables
	.DIRECT("mov dword [fn_arg_num], -3")
	"]"
		$(BODY)
	.DIRECT("mov dword [fn_arg_num], 0")
		->("mov esp, ebp")
		->("pop ebp")
		->("ret")
	.LABEL(*1 ":")
	.DIRECT("mov byte [is_global], 1");



// ------------------------------ Function Call --------------------------------

FUNC_CALL = ID %
	.DIRECT("mov dword [used_arg_count], 0")
	CALL_ARGS
	->("call " %)
	// Revert the stack pointer to it's original position
	.DIRECT("mov ebx, dword [used_arg_count]")
	.DIRECT("imul ebx, ebx, 4")
	.UF("add esp, ")
	.DIRECT("mov esi, ebx")
	.DIRECT("mov edi, outbuff")
	.DIRECT("add edi, dword [outbuff_offset]")
	.DIRECT("call inttostr")
	.DIRECT("add dword [outbuff_offset], eax")
	.DIRECT("mov dword [used_arg_count], 0")
	.UF(.NL .TB)
	.UF("push eax" .NL .TB);

// ------------------------- Function Call Arguments ---------------------------

CALL_ARGS = $((
			NUMBER %<"push " *>
		| "[" .DIRECT("push dword [used_arg_count]") (FUNC_CALL | ARITHMETIC) .DIRECT("pop dword [used_arg_count]") "]"
			%<"">
		| SYMBOL_TABLE_PUSH_BUFFER
		| STRING_ARG)
		.DIRECT("inc dword [used_arg_count]"))
	.DIRECT("mov ecx, dword [used_arg_count]")
	.DIRECT("loop_pop_args:")
	.DIRECT("cmp ecx, 0")
	.DIRECT("je loop_pop_args_end")
	.DIRECT("push ecx")
	->(%)
	.DIRECT("pop ecx")
	.DIRECT("dec ecx")
	.DIRECT("jmp loop_pop_args")
	.DIRECT("loop_pop_args_end:");

SYMBOL_TABLE_PUSH_BUFFER = ID 
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, last_match")
	.DIRECT("call hash_get") // Variable information now in eax
		// We need to check whether we're in the global scope
	.DIRECT("cmp eax, 0x80000000")
	.DIRECT("jne stpb_local")

	.DIRECT("mov esi, push_prefix_global")
	.DIRECT("mov edi, push_buffer")
	.DIRECT("call buffc")
	.DIRECT("mov esi, last_match")
	.DIRECT("mov edi, push_buffer")
	.DIRECT("add edi, 12")
	.DIRECT("call buffc")
	.DIRECT("mov edi, push_buffer")
	.DIRECT("add edi, 12")
	.DIRECT("mov byte [edi+eax], ']'")
	.DIRECT("mov byte [edi+eax+1], 0x00")
	.DIRECT("mov esi, push_buffer")
	.DIRECT("mov edi, str_vector_8192")
	.DIRECT("call vector_push_string_mm32")
	.DIRECT("jmp stpb_end")
	.DIRECT("stpb_local:")
	// We need to get the index of the argument from the symbol table
	// We can do this by doing `8 + (arg_count - index) * 4`
	// This will account for the 8 bytes of the function call (esp and ip)
	.DIRECT("push eax")
	.DIRECT("mov esi, push_prefix")
	.DIRECT("mov edi, push_buffer")
	.DIRECT("call buffc")
	.DIRECT("pop eax")
	.DIRECT("imul eax, eax, 4") // (arg_count - index) * 4
	.DIRECT("add eax, 8") // 8 + (arg_count - index) * 4
	.DIRECT("mov esi, eax") // print the number
	.DIRECT("mov edi, push_buffer")
	.DIRECT("add edi, 15")
	.DIRECT("call inttostrsigned")
	.DIRECT("mov edi, push_buffer")
	.DIRECT("add edi, 15")
	.DIRECT("mov byte [edi+eax], ']'")
	.DIRECT("mov byte [edi+eax+1], 0x00")
	.DIRECT("mov esi, push_buffer")
	.DIRECT("mov edi, str_vector_8192")
	.DIRECT("call vector_push_string_mm32")
	.DIRECT("stpb_end:");

STRING_ARG = STRING 
			.LABEL("section .data")
				->(*3 " db " * ", 0x00")
			.LABEL("section .text")
				%<"">
				->("push " *3);


BINOP_ARGS = $((NUMBER ->("push " *)
	| ("[" (FUNC_CALL | ARITHMETIC) "]")
	| SYMBOL_TABLE_PUSH) $((
			NUMBER ->("push " *)
		| ("[" (FUNC_CALL | ARITHMETIC) "]")
		| SYMBOL_TABLE_PUSH)
		->("pop ebx"))
	->("pop eax"));

SYMBOL_TABLE_PUSH = ID 
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, last_match")
	.DIRECT("call hash_get") // Variable information now in eax
		// We need to check whether we're in the global scope
	.DIRECT("cmp eax, 0x80000000")
	.DIRECT("jne stp_local")
	->("push dword [" * "]")
	.DIRECT("jmp stp_end")
	.DIRECT("stp_local:")
	// We need to get the index of the argument from the symbol table
	// We can do this by doing `8 + (arg_count - index) * 4`
	// This will account for the 8 bytes of the function call (esp and ip)
	.DIRECT("push eax")
	.RS("push dword [ebp")
	.DIRECT("pop eax")
	.DIRECT("imul eax, eax, 4") // (arg_count - index) * 4
	.DIRECT("add eax, 8") // 8 + (arg_count - index) * 4
	.DIRECT("mov esi, eax") // print the number
	.DIRECT("mov edi, outbuff")
	.DIRECT("add edi, dword [outbuff_offset]")
	.DIRECT("call inttostrsigned")
	.DIRECT("add dword [outbuff_offset], eax")
	->("] ; get " *)
	.DIRECT("stp_end:");

// ----------------------------- Symbol Table Id -------------------------------

// TODO: Replace with SYMBOL_TABLE_ID<reg>
SYMBOL_TABLE_ID = ID 
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, last_match")
	.DIRECT("call hash_get") // Variable information now in eax
		// We need to check whether we're in the global scope
	.DIRECT("cmp eax, 0x80000000")
	.DIRECT("jne st_local")
	->("mov eax, dword [" * "]")
	.DIRECT("jmp st_end")
	.DIRECT("st_local:")
	// We need to get the index of the argument from the symbol table
	// We can do this by doing `8 + (arg_count - index) * 4`
	// This will account for the 8 bytes of the function call (esp and ip)
	.DIRECT("push eax")
	.RS("mov eax, dword [ebp")
	.DIRECT("pop eax")
	.DIRECT("imul eax, eax, 4") // (arg_count - index) * 4
	.DIRECT("add eax, 8") // 8 + (arg_count - index) * 4
	.DIRECT("mov esi, eax") // print the number
	.DIRECT("mov edi, outbuff")
	.DIRECT("add edi, dword [outbuff_offset]")
	.DIRECT("call inttostrsigned")
	.DIRECT("add dword [outbuff_offset], eax")
	->("] ; get " *)
	.DIRECT("st_end:");

SYMBOL_TABLE_ID_EBX = ID 
	.DIRECT("mov edi, symbol_table")
	.DIRECT("mov esi, last_match")
	.DIRECT("call hash_get") // Variable information now in eax
		// We need to check whether we're in the global scope
	.DIRECT("cmp eax, 0x80000000")
	.DIRECT("jne st_ebx_local")
	->("mov ebx, dword [" * "]")
	.DIRECT("jmp st_ebx_end")
	.DIRECT("st_ebx_local:")
	// We need to get the index of the argument from the symbol table
	// We can do this by doing `8 + (arg_count - index) * 4`
	// This will account for the 8 bytes of the function call (esp and ip)
	.DIRECT("push eax")
	.RS("mov ebx, dword [ebp")
	.DIRECT("pop eax")
	.DIRECT("imul eax, eax, 4") // (arg_count - index) * 4
	.DIRECT("add eax, 8") // 8 + (arg_count - index) * 4
	.DIRECT("mov esi, eax") // print the number
	.DIRECT("mov edi, outbuff")
	.DIRECT("add edi, dword [outbuff_offset]")
	.DIRECT("call inttostrsigned")
	.DIRECT("add dword [outbuff_offset], eax")
	->("] ; get " *)
	.DIRECT("st_ebx_end:");

// -------------------------------- Comments -----------------------------------

COMMENT = "//" .NOT 10;

.TOKENS

// Remove any leading whitespace
PREFIX = $.ANY(32!9!13!10);

// Match numbers (sequence of digits)
NUMBER = PREFIX .TOKEN DIGIT $DIGIT .DELTOK;

// Match any digit
DIGIT  = .ANY(48:57);

// Match any sequence of characters and digits, may not start with a digit.
ID     = PREFIX .TOKEN ALPHA $(ALPHA | DIGIT) .DELTOK;

// Matches any uppercase or lowercase character as well as underscore
ALPHA  = .ANY(65:90!95!97:122) ;

// Matches anything but double quotes that is enclosed by double quotes.
// e.g. "hello world" but not "awd "inner" "
STRING = PREFIX .TOKEN .ANY(34) $.ANYBUT(13!10!34) .ANY(34) .DELTOK;

// Same as STRING but does not capture the double quotes.
RAW 	 = PREFIX .ANY(34) .TOKEN $.ANYBUT(13!10!34) .DELTOK .ANY(34);