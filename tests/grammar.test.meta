.SYNTAX PROGRAM

/* Program Entry */
PROGRAM = $((".DATA" .LABEL(".data") $(DATA_DEFINITION | COMMENT)) |
						(".SYNTAX" .ID 
							.LABEL(".text") 
							.LABEL("_start:")
							-> ("mov edi, 0x00")
							-> ("mov eax, 0x00")
							-> ("mov esi, [input_string] ; Read Text input into `input_string`")
							-> ("mov edx, 12000 ; We can read up to 12000 bytes")
							-> ("int 0x80")
							-> ("jmp " *)
							.LABEL("strip:")
							-> ("mov esi, [input_string]")
							-> ("cmp [esi], 32 ; Whitespace Character")
							-> ("call strip_first_character")
							-> ("ret")
							.LABEL("strip_first_character:")
							-> ("mov [input_string], 0x00")
							-> ("ret")
							.LABEL("print:")
							-> ("mov edi, 0x01")
							-> ("mov eax, 0x04")
							-> ("mov esi, [output_string]")
							-> ("int 0x80")
							-> ("ret")
							.LABEL("newline:")
							-> ("mov eax, [output_string]")
							-> ("mov [eax], 0x0a")
							-> ("add eax, 1")
							-> ("mov ecx, 7")
							.LABEL("fill_loop:")
							-> ("mov [eax], 32")
							-> ("add eax, 1")
							-> ("loop fill_loop")
							-> ("mov [eax], 0x00")
							-> ("call print")
							-> ("ret")
					$(VARIABLE_ASSIGNMENT | DEFINITION | COMMENT) ".END" -> ("END")))
					.LABEL(".bss")
					->("output_string resb 500")
					->("input_string resb 12000")
					/* Reserve enough space for any output call that might come up */;

DATA_DEFINITION = .ID .LABEL("    " * ":") "=" DATA_TYPE ";";

DATA_TYPE = (.STRING ->("string " *)) | (.NUMBER ->("number " *));

VARIABLE_ASSIGNMENT = "[" .ID .OUT("mov [" * "], ") "]" "=" (.STRING ->("dword " *) | .NUMBER ->(*)) ";" -> ("ret");

OUT1 = "*1"     	-> ("GN1")
	| "*2"     	-> ("GN2")
	| "*"      	-> ("CI")
	| .STRING  	-> ("mov [output_string], dword " *)
							-> ("call print")
	| "[" .ID -> ("mov eax, [" * "]") "]";

/* This section is responsible for parsing the output directive `->()`*/
/* Or to parse a `.LABEL` directive, which will dedent the output to create a new labeled section */

OUTPUT = ("->" "(" $ OUT1 ")" 
		| ".LABEL" -> ("LB") "(" $ OUT1 ")") ->("call newline")
		| ".OUT" "(" $ OUT1 ")";

/* If we hit an identifier we jump to it using `call` - Call */

EX3 = .ID               -> ("call " *)

	/* If we hit a supposed string we will start matching the string */

	| .STRING           -> ("TST " *)

	/* Match the .ID directive, causing the compiler to match an identifier */

	| ".ID"             -> ("ID")

	/* Trigger the return flag manually */

	| ".RET"	-> ("ret")

	/* This is a command directive, it will take a parameter to not match against as a string */
	/* This will cause the compiler to break once it finds the specified string */

	| ".NOT" .STRING	-> ("NOT " *)

	/* This will match the ".NUMBER" directive, which will itself match any numbers */

	| ".NUMBER"         -> ("NUM")

	/* This will match the ".STRING" directive, which will itself match a string */
	/* Strings can be single quoted ('String') or double quoted ("Also string") for ease of use */

	| ".STRING"         -> ("SR")

	/* This will match an expression inside parentheses, like in math, parens' will cause the expression to be favored */

	| "(" EX1 ")"

	/* This will set the branch flag to `true`, basically meaning that it will always continue */
	/* This might be useful if you want to match nothing or just continue because of something else */

	| ".EMPTY" ->("SET")

	| "$" .LABEL(*1 ":") EX3 -> ("je " *1) -> ("SET");

EX2 = (EX3 -> ("jne " *1) | OUTPUT) $ (EX3 -> ("BE") | OUTPUT) .LABEL(*1 ":");

EX1 = EX2 $ ("|" -> ("je " *1) EX2 | COMMENT) .LABEL(*1 ":");

DEFINITION = .ID .LABEL(* ":") "=" EX1 ";" -> ("ret");



/* SECTION: This defines how comments should look - like this ðŸ˜‰ */
/* We start by matching an open bracket and continue matching anything BUT a closing bracket */
/* Then we need to match the closing bracket since the matcher has stopped once it reached it */

COMMENT = "/*" .NOT "*/" "*/";

.END
